/* simple-statusbar.c generated by valac 0.28.0, the Vala compiler
 * generated from simple-statusbar.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>


#define TYPE_FILE_OPEARTION (file_opeartion_get_type ())

#define TYPE_SIMPLE_STATUSBAR (simple_statusbar_get_type ())
#define SIMPLE_STATUSBAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SIMPLE_STATUSBAR, SimpleStatusbar))
#define SIMPLE_STATUSBAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SIMPLE_STATUSBAR, SimpleStatusbarClass))
#define IS_SIMPLE_STATUSBAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SIMPLE_STATUSBAR))
#define IS_SIMPLE_STATUSBAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SIMPLE_STATUSBAR))
#define SIMPLE_STATUSBAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SIMPLE_STATUSBAR, SimpleStatusbarClass))

typedef struct _SimpleStatusbar SimpleStatusbar;
typedef struct _SimpleStatusbarClass SimpleStatusbarClass;
typedef struct _SimpleStatusbarPrivate SimpleStatusbarPrivate;

#define TYPE_SIMPLE_LANGUAGE_PICKER (simple_language_picker_get_type ())
#define SIMPLE_LANGUAGE_PICKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SIMPLE_LANGUAGE_PICKER, SimpleLanguagePicker))
#define SIMPLE_LANGUAGE_PICKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SIMPLE_LANGUAGE_PICKER, SimpleLanguagePickerClass))
#define IS_SIMPLE_LANGUAGE_PICKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SIMPLE_LANGUAGE_PICKER))
#define IS_SIMPLE_LANGUAGE_PICKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SIMPLE_LANGUAGE_PICKER))
#define SIMPLE_LANGUAGE_PICKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SIMPLE_LANGUAGE_PICKER, SimpleLanguagePickerClass))

typedef struct _SimpleLanguagePicker SimpleLanguagePicker;
typedef struct _SimpleLanguagePickerClass SimpleLanguagePickerClass;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_PROGRAMMING_LANGUAGES (programming_languages_get_type ())
#define PROGRAMMING_LANGUAGES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROGRAMMING_LANGUAGES, ProgrammingLanguages))
#define PROGRAMMING_LANGUAGES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROGRAMMING_LANGUAGES, ProgrammingLanguagesClass))
#define IS_PROGRAMMING_LANGUAGES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROGRAMMING_LANGUAGES))
#define IS_PROGRAMMING_LANGUAGES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROGRAMMING_LANGUAGES))
#define PROGRAMMING_LANGUAGES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROGRAMMING_LANGUAGES, ProgrammingLanguagesClass))

typedef struct _ProgrammingLanguages ProgrammingLanguages;
typedef struct _ProgrammingLanguagesClass ProgrammingLanguagesClass;
#define _programming_languages_unref0(var) ((var == NULL) ? NULL : (var = (programming_languages_unref (var), NULL)))

typedef enum  {
	FILE_OPEARTION_NULL_OPERATION,
	FILE_OPEARTION_NEW_FILE,
	FILE_OPEARTION_OPEN_FILE,
	FILE_OPEARTION_EDIT_FILE,
	FILE_OPEARTION_SAVE_FILE,
	FILE_OPEARTION_CLOSE_FILE,
	FILE_OPEARTION_BUILD_FILE,
	FILE_OPEARTION_BUILD_DONE,
	FILE_OPEARTION_BUILD_FAIL
} FileOpeartion;

struct _SimpleStatusbar {
	GtkBox parent_instance;
	SimpleStatusbarPrivate * priv;
};

struct _SimpleStatusbarClass {
	GtkBoxClass parent_class;
};

struct _SimpleStatusbarPrivate {
	SimpleLanguagePicker* lang_picker;
	MainWindow* parent_window;
	GtkEventBox* evt_box;
	GtkLabel* _label;
	GtkStatusbar* status;
	guint context_id;
};


static gpointer simple_statusbar_parent_class = NULL;

GType file_opeartion_get_type (void) G_GNUC_CONST;
GType simple_statusbar_get_type (void) G_GNUC_CONST;
GType simple_language_picker_get_type (void) G_GNUC_CONST;
GType main_window_get_type (void) G_GNUC_CONST;
#define SIMPLE_STATUSBAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SIMPLE_STATUSBAR, SimpleStatusbarPrivate))
enum  {
	SIMPLE_STATUSBAR_DUMMY_PROPERTY,
	SIMPLE_STATUSBAR_LABEL
};
SimpleStatusbar* simple_statusbar_new (MainWindow* parent);
SimpleStatusbar* simple_statusbar_construct (GType object_type, MainWindow* parent);
static void simple_statusbar_create_widgets (SimpleStatusbar* self);
static gboolean simple_statusbar_on_label_pressed (SimpleStatusbar* self, GdkEventButton* evt);
static gboolean _simple_statusbar_on_label_pressed_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
SimpleLanguagePicker* simple_language_picker_new (GtkWidget* parent);
SimpleLanguagePicker* simple_language_picker_construct (GType object_type, GtkWidget* parent);
static void simple_statusbar_change_syntax (SimpleStatusbar* self, const gchar* language);
static void _simple_statusbar_change_syntax_simple_language_picker_language_selected (SimpleLanguagePicker* _sender, const gchar* language, gpointer self);
void simple_statusbar_toggle_picker (SimpleStatusbar* self);
void simple_statusbar_refresh_statusbar (SimpleStatusbar* self, FileOpeartion operation, const gchar* file_name);
void simple_statusbar_refresh_language (SimpleStatusbar* self, const gchar* file_name);
gpointer programming_languages_ref (gpointer instance);
void programming_languages_unref (gpointer instance);
GParamSpec* param_spec_programming_languages (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_programming_languages (GValue* value, gpointer v_object);
void value_take_programming_languages (GValue* value, gpointer v_object);
gpointer value_get_programming_languages (const GValue* value);
GType programming_languages_get_type (void) G_GNUC_CONST;
ProgrammingLanguages* programming_languages_new (void);
ProgrammingLanguages* programming_languages_construct (GType object_type);
gchar* programming_languages_get_lang_name (ProgrammingLanguages* self, const gchar* filename);
GtkLabel* simple_statusbar_get_label (SimpleStatusbar* self);
static void simple_statusbar_finalize (GObject* obj);
static void _vala_simple_statusbar_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);


GType file_opeartion_get_type (void) {
	static volatile gsize file_opeartion_type_id__volatile = 0;
	if (g_once_init_enter (&file_opeartion_type_id__volatile)) {
		static const GEnumValue values[] = {{FILE_OPEARTION_NULL_OPERATION, "FILE_OPEARTION_NULL_OPERATION", "null-operation"}, {FILE_OPEARTION_NEW_FILE, "FILE_OPEARTION_NEW_FILE", "new-file"}, {FILE_OPEARTION_OPEN_FILE, "FILE_OPEARTION_OPEN_FILE", "open-file"}, {FILE_OPEARTION_EDIT_FILE, "FILE_OPEARTION_EDIT_FILE", "edit-file"}, {FILE_OPEARTION_SAVE_FILE, "FILE_OPEARTION_SAVE_FILE", "save-file"}, {FILE_OPEARTION_CLOSE_FILE, "FILE_OPEARTION_CLOSE_FILE", "close-file"}, {FILE_OPEARTION_BUILD_FILE, "FILE_OPEARTION_BUILD_FILE", "build-file"}, {FILE_OPEARTION_BUILD_DONE, "FILE_OPEARTION_BUILD_DONE", "build-done"}, {FILE_OPEARTION_BUILD_FAIL, "FILE_OPEARTION_BUILD_FAIL", "build-fail"}, {0, NULL, NULL}};
		GType file_opeartion_type_id;
		file_opeartion_type_id = g_enum_register_static ("FileOpeartion", values);
		g_once_init_leave (&file_opeartion_type_id__volatile, file_opeartion_type_id);
	}
	return file_opeartion_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


SimpleStatusbar* simple_statusbar_construct (GType object_type, MainWindow* parent) {
	SimpleStatusbar * self = NULL;
	MainWindow* _tmp0_ = NULL;
	MainWindow* _tmp1_ = NULL;
	g_return_val_if_fail (parent != NULL, NULL);
	self = (SimpleStatusbar*) g_object_new (object_type, NULL);
	_tmp0_ = parent;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->parent_window);
	self->priv->parent_window = _tmp1_;
	simple_statusbar_create_widgets (self);
	return self;
}


SimpleStatusbar* simple_statusbar_new (MainWindow* parent) {
	return simple_statusbar_construct (TYPE_SIMPLE_STATUSBAR, parent);
}


static gboolean _simple_statusbar_on_label_pressed_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = simple_statusbar_on_label_pressed ((SimpleStatusbar*) self, event);
	return result;
}


static void _simple_statusbar_change_syntax_simple_language_picker_language_selected (SimpleLanguagePicker* _sender, const gchar* language, gpointer self) {
	simple_statusbar_change_syntax ((SimpleStatusbar*) self, language);
}


static void simple_statusbar_create_widgets (SimpleStatusbar* self) {
	GtkStatusbar* _tmp0_ = NULL;
	GtkStatusbar* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	GtkStatusbar* _tmp3_ = NULL;
	GtkLabel* _tmp4_ = NULL;
	GtkLabel* _tmp5_ = NULL;
	GtkEventBox* _tmp6_ = NULL;
	GtkEventBox* _tmp7_ = NULL;
	GtkLabel* _tmp8_ = NULL;
	GtkEventBox* _tmp9_ = NULL;
	GtkEventBox* _tmp10_ = NULL;
	GtkEventBox* _tmp11_ = NULL;
	GtkLabel* _tmp12_ = NULL;
	SimpleLanguagePicker* _tmp13_ = NULL;
	SimpleLanguagePicker* _tmp14_ = NULL;
	GtkStatusbar* _tmp15_ = NULL;
	GtkEventBox* _tmp16_ = NULL;
	g_return_if_fail (self != NULL);
	gtk_orientable_set_orientation ((GtkOrientable*) self, GTK_ORIENTATION_HORIZONTAL);
	gtk_box_set_spacing ((GtkBox*) self, 0);
	_tmp0_ = (GtkStatusbar*) gtk_statusbar_new ();
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->status);
	self->priv->status = _tmp0_;
	_tmp1_ = self->priv->status;
	_tmp2_ = gtk_statusbar_get_context_id (_tmp1_, "status");
	self->priv->context_id = _tmp2_;
	_tmp3_ = self->priv->status;
	gtk_widget_show ((GtkWidget*) _tmp3_);
	_tmp4_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->priv->_label);
	self->priv->_label = _tmp4_;
	_tmp5_ = self->priv->_label;
	gtk_widget_show ((GtkWidget*) _tmp5_);
	_tmp6_ = (GtkEventBox*) gtk_event_box_new ();
	g_object_ref_sink (_tmp6_);
	_g_object_unref0 (self->priv->evt_box);
	self->priv->evt_box = _tmp6_;
	_tmp7_ = self->priv->evt_box;
	_tmp8_ = self->priv->_label;
	g_object_set ((GtkContainer*) _tmp7_, "child", (GtkWidget*) _tmp8_, NULL);
	_tmp9_ = self->priv->evt_box;
	gtk_event_box_set_above_child (_tmp9_, TRUE);
	_tmp10_ = self->priv->evt_box;
	g_signal_connect_object ((GtkWidget*) _tmp10_, "button-press-event", (GCallback) _simple_statusbar_on_label_pressed_gtk_widget_button_press_event, self, 0);
	_tmp11_ = self->priv->evt_box;
	gtk_widget_show ((GtkWidget*) _tmp11_);
	_tmp12_ = self->priv->_label;
	_tmp13_ = simple_language_picker_new ((GtkWidget*) _tmp12_);
	g_object_ref_sink (_tmp13_);
	_g_object_unref0 (self->priv->lang_picker);
	self->priv->lang_picker = _tmp13_;
	_tmp14_ = self->priv->lang_picker;
	g_signal_connect_object (_tmp14_, "language-selected", (GCallback) _simple_statusbar_change_syntax_simple_language_picker_language_selected, self, 0);
	_tmp15_ = self->priv->status;
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp15_, FALSE, TRUE, (guint) 0);
	_tmp16_ = self->priv->evt_box;
	gtk_box_pack_end ((GtkBox*) self, (GtkWidget*) _tmp16_, FALSE, TRUE, (guint) 15);
}


void simple_statusbar_toggle_picker (SimpleStatusbar* self) {
	SimpleLanguagePicker* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->lang_picker;
	_tmp1_ = gtk_widget_get_visible ((GtkWidget*) _tmp0_);
	if (_tmp1_) {
		SimpleLanguagePicker* _tmp2_ = NULL;
		_tmp2_ = self->priv->lang_picker;
		gtk_widget_hide ((GtkWidget*) _tmp2_);
	} else {
		SimpleLanguagePicker* _tmp3_ = NULL;
		_tmp3_ = self->priv->lang_picker;
		gtk_widget_show_all ((GtkWidget*) _tmp3_);
	}
}


void simple_statusbar_refresh_statusbar (SimpleStatusbar* self, FileOpeartion operation, const gchar* file_name) {
	GtkStatusbar* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	gchar* build_string = NULL;
	gchar* _tmp2_ = NULL;
	FileOpeartion _tmp3_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->status;
	_tmp1_ = self->priv->context_id;
	gtk_statusbar_pop (_tmp0_, _tmp1_);
	_tmp2_ = g_strdup ("Building...");
	build_string = _tmp2_;
	_tmp3_ = operation;
	switch (_tmp3_) {
		case FILE_OPEARTION_NULL_OPERATION:
		{
			GtkStatusbar* _tmp4_ = NULL;
			guint _tmp5_ = 0U;
			_tmp4_ = self->priv->status;
			_tmp5_ = self->priv->context_id;
			gtk_statusbar_push (_tmp4_, _tmp5_, "");
			break;
		}
		case FILE_OPEARTION_NEW_FILE:
		{
			GtkStatusbar* _tmp6_ = NULL;
			guint _tmp7_ = 0U;
			const gchar* _tmp8_ = NULL;
			_tmp6_ = self->priv->status;
			_tmp7_ = self->priv->context_id;
			_tmp8_ = _ ("New file");
			gtk_statusbar_push (_tmp6_, _tmp7_, _tmp8_);
			break;
		}
		case FILE_OPEARTION_OPEN_FILE:
		{
			GtkStatusbar* _tmp9_ = NULL;
			guint _tmp10_ = 0U;
			const gchar* _tmp11_ = NULL;
			gchar* _tmp12_ = NULL;
			gchar* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			gchar* _tmp15_ = NULL;
			gchar* _tmp16_ = NULL;
			_tmp9_ = self->priv->status;
			_tmp10_ = self->priv->context_id;
			_tmp11_ = _ ("Opened");
			_tmp12_ = g_strconcat (_tmp11_, ": ", NULL);
			_tmp13_ = _tmp12_;
			_tmp14_ = file_name;
			_tmp15_ = g_strconcat (_tmp13_, _tmp14_, NULL);
			_tmp16_ = _tmp15_;
			gtk_statusbar_push (_tmp9_, _tmp10_, _tmp16_);
			_g_free0 (_tmp16_);
			_g_free0 (_tmp13_);
			break;
		}
		case FILE_OPEARTION_EDIT_FILE:
		{
			GtkStatusbar* _tmp17_ = NULL;
			guint _tmp18_ = 0U;
			const gchar* _tmp19_ = NULL;
			_tmp17_ = self->priv->status;
			_tmp18_ = self->priv->context_id;
			_tmp19_ = _ ("Editing...");
			gtk_statusbar_push (_tmp17_, _tmp18_, _tmp19_);
			break;
		}
		case FILE_OPEARTION_SAVE_FILE:
		{
			GtkStatusbar* _tmp20_ = NULL;
			guint _tmp21_ = 0U;
			const gchar* _tmp22_ = NULL;
			gchar* _tmp23_ = NULL;
			gchar* _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			gchar* _tmp26_ = NULL;
			gchar* _tmp27_ = NULL;
			_tmp20_ = self->priv->status;
			_tmp21_ = self->priv->context_id;
			_tmp22_ = _ ("Saved");
			_tmp23_ = g_strconcat (_tmp22_, ": ", NULL);
			_tmp24_ = _tmp23_;
			_tmp25_ = file_name;
			_tmp26_ = g_strconcat (_tmp24_, _tmp25_, NULL);
			_tmp27_ = _tmp26_;
			gtk_statusbar_push (_tmp20_, _tmp21_, _tmp27_);
			_g_free0 (_tmp27_);
			_g_free0 (_tmp24_);
			break;
		}
		case FILE_OPEARTION_CLOSE_FILE:
		{
			GtkStatusbar* _tmp28_ = NULL;
			guint _tmp29_ = 0U;
			const gchar* _tmp30_ = NULL;
			gchar* _tmp31_ = NULL;
			gchar* _tmp32_ = NULL;
			const gchar* _tmp33_ = NULL;
			gchar* _tmp34_ = NULL;
			gchar* _tmp35_ = NULL;
			_tmp28_ = self->priv->status;
			_tmp29_ = self->priv->context_id;
			_tmp30_ = _ ("Closed");
			_tmp31_ = g_strconcat (_tmp30_, ": ", NULL);
			_tmp32_ = _tmp31_;
			_tmp33_ = file_name;
			_tmp34_ = g_strconcat (_tmp32_, _tmp33_, NULL);
			_tmp35_ = _tmp34_;
			gtk_statusbar_push (_tmp28_, _tmp29_, _tmp35_);
			_g_free0 (_tmp35_);
			_g_free0 (_tmp32_);
			break;
		}
		case FILE_OPEARTION_BUILD_FILE:
		{
			GtkStatusbar* _tmp36_ = NULL;
			guint _tmp37_ = 0U;
			const gchar* _tmp38_ = NULL;
			const gchar* _tmp39_ = NULL;
			_tmp36_ = self->priv->status;
			_tmp37_ = self->priv->context_id;
			_tmp38_ = build_string;
			_tmp39_ = _ (_tmp38_);
			gtk_statusbar_push (_tmp36_, _tmp37_, _tmp39_);
			break;
		}
		case FILE_OPEARTION_BUILD_DONE:
		{
			GtkStatusbar* _tmp40_ = NULL;
			guint _tmp41_ = 0U;
			const gchar* _tmp42_ = NULL;
			const gchar* _tmp43_ = NULL;
			gchar* _tmp44_ = NULL;
			gchar* _tmp45_ = NULL;
			const gchar* _tmp46_ = NULL;
			gchar* _tmp47_ = NULL;
			gchar* _tmp48_ = NULL;
			_tmp40_ = self->priv->status;
			_tmp41_ = self->priv->context_id;
			_tmp42_ = build_string;
			_tmp43_ = _ (_tmp42_);
			_tmp44_ = g_strconcat (_tmp43_, " ", NULL);
			_tmp45_ = _tmp44_;
			_tmp46_ = _ ("Done");
			_tmp47_ = g_strconcat (_tmp45_, _tmp46_, NULL);
			_tmp48_ = _tmp47_;
			gtk_statusbar_push (_tmp40_, _tmp41_, _tmp48_);
			_g_free0 (_tmp48_);
			_g_free0 (_tmp45_);
			break;
		}
		case FILE_OPEARTION_BUILD_FAIL:
		{
			GtkStatusbar* _tmp49_ = NULL;
			guint _tmp50_ = 0U;
			const gchar* _tmp51_ = NULL;
			const gchar* _tmp52_ = NULL;
			gchar* _tmp53_ = NULL;
			gchar* _tmp54_ = NULL;
			const gchar* _tmp55_ = NULL;
			gchar* _tmp56_ = NULL;
			gchar* _tmp57_ = NULL;
			_tmp49_ = self->priv->status;
			_tmp50_ = self->priv->context_id;
			_tmp51_ = build_string;
			_tmp52_ = _ (_tmp51_);
			_tmp53_ = g_strconcat (_tmp52_, " ", NULL);
			_tmp54_ = _tmp53_;
			_tmp55_ = _ ("Failed");
			_tmp56_ = g_strconcat (_tmp54_, _tmp55_, NULL);
			_tmp57_ = _tmp56_;
			gtk_statusbar_push (_tmp49_, _tmp50_, _tmp57_);
			_g_free0 (_tmp57_);
			_g_free0 (_tmp54_);
			break;
		}
		default:
		break;
	}
	_g_free0 (build_string);
}


void simple_statusbar_refresh_language (SimpleStatusbar* self, const gchar* file_name) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = file_name;
	if (_tmp0_ == NULL) {
		GtkLabel* _tmp1_ = NULL;
		_tmp1_ = self->priv->_label;
		gtk_label_set_label (_tmp1_, "");
	} else {
		ProgrammingLanguages* plangs = NULL;
		ProgrammingLanguages* _tmp2_ = NULL;
		gchar* p_name = NULL;
		ProgrammingLanguages* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		GtkLabel* _tmp9_ = NULL;
		_tmp2_ = programming_languages_new ();
		plangs = _tmp2_;
		_tmp3_ = plangs;
		_tmp4_ = file_name;
		_tmp5_ = programming_languages_get_lang_name (_tmp3_, _tmp4_);
		p_name = _tmp5_;
		_tmp7_ = p_name;
		if (_tmp7_ == NULL) {
			_tmp6_ = "Plain text";
		} else {
			const gchar* _tmp8_ = NULL;
			_tmp8_ = p_name;
			_tmp6_ = _tmp8_;
		}
		_tmp9_ = self->priv->_label;
		gtk_label_set_label (_tmp9_, _tmp6_);
		_g_free0 (p_name);
		_programming_languages_unref0 (plangs);
	}
}


static gboolean simple_statusbar_on_label_pressed (SimpleStatusbar* self, GdkEventButton* evt) {
	gboolean result = FALSE;
	SimpleLanguagePicker* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (evt != NULL, FALSE);
	_tmp0_ = self->priv->lang_picker;
	_tmp1_ = gtk_widget_get_visible ((GtkWidget*) _tmp0_);
	if (_tmp1_) {
		SimpleLanguagePicker* _tmp2_ = NULL;
		_tmp2_ = self->priv->lang_picker;
		gtk_widget_hide ((GtkWidget*) _tmp2_);
	} else {
		SimpleLanguagePicker* _tmp3_ = NULL;
		_tmp3_ = self->priv->lang_picker;
		gtk_widget_show_all ((GtkWidget*) _tmp3_);
	}
	result = TRUE;
	return result;
}


static void simple_statusbar_change_syntax (SimpleStatusbar* self, const gchar* language) {
	GtkLabel* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (language != NULL);
	_tmp0_ = self->priv->_label;
	_tmp1_ = language;
	gtk_label_set_label (_tmp0_, _tmp1_);
	_tmp2_ = language;
	g_signal_emit_by_name (self, "change-syntax-request", _tmp2_);
}


GtkLabel* simple_statusbar_get_label (SimpleStatusbar* self) {
	GtkLabel* result;
	GtkLabel* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_label;
	result = _tmp0_;
	return result;
}


static void simple_statusbar_class_init (SimpleStatusbarClass * klass) {
	simple_statusbar_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SimpleStatusbarPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_simple_statusbar_get_property;
	G_OBJECT_CLASS (klass)->finalize = simple_statusbar_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SIMPLE_STATUSBAR_LABEL, g_param_spec_object ("label", "label", "label", gtk_label_get_type (), G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_signal_new ("change_syntax_request", TYPE_SIMPLE_STATUSBAR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}


static void simple_statusbar_instance_init (SimpleStatusbar * self) {
	self->priv = SIMPLE_STATUSBAR_GET_PRIVATE (self);
}


static void simple_statusbar_finalize (GObject* obj) {
	SimpleStatusbar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SIMPLE_STATUSBAR, SimpleStatusbar);
	_g_object_unref0 (self->priv->lang_picker);
	_g_object_unref0 (self->priv->parent_window);
	_g_object_unref0 (self->priv->evt_box);
	_g_object_unref0 (self->priv->_label);
	_g_object_unref0 (self->priv->status);
	G_OBJECT_CLASS (simple_statusbar_parent_class)->finalize (obj);
}


GType simple_statusbar_get_type (void) {
	static volatile gsize simple_statusbar_type_id__volatile = 0;
	if (g_once_init_enter (&simple_statusbar_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SimpleStatusbarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) simple_statusbar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SimpleStatusbar), 0, (GInstanceInitFunc) simple_statusbar_instance_init, NULL };
		GType simple_statusbar_type_id;
		simple_statusbar_type_id = g_type_register_static (gtk_box_get_type (), "SimpleStatusbar", &g_define_type_info, 0);
		g_once_init_leave (&simple_statusbar_type_id__volatile, simple_statusbar_type_id);
	}
	return simple_statusbar_type_id__volatile;
}


static void _vala_simple_statusbar_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SimpleStatusbar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_SIMPLE_STATUSBAR, SimpleStatusbar);
	switch (property_id) {
		case SIMPLE_STATUSBAR_LABEL:
		g_value_set_object (value, simple_statusbar_get_label (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



